"""
This type stub file was generated by pyright.
"""

EMBEDDED_PEAK_TUPLE = ...
INTERMEDIATE_REGION = ...
PRIVATE_POINT_NUMBERS = ...
DELTAS_ARE_ZERO = ...
DELTAS_ARE_WORDS = ...
DELTA_RUN_COUNT_MASK = ...
POINTS_ARE_WORDS = ...
POINT_RUN_COUNT_MASK = ...
TUPLES_SHARE_POINT_NUMBERS = ...
TUPLE_COUNT_MASK = ...
TUPLE_INDEX_MASK = ...
log = ...
class TupleVariation:
	def __init__(self, axes, coordinates) -> None:
		...
	
	def __repr__(self): # -> str:
		...
	
	def __eq__(self, other) -> bool:
		...
	
	def getUsedPoints(self): # -> frozenset[Unknown] | frozenset[int] | None:
		...
	
	def hasImpact(self): # -> bool:
		"""Returns True if this TupleVariation has any visible impact.

		If the result is False, the TupleVariation can be omitted from the font
		without making any visible difference.
		"""
		...
	
	def toXML(self, writer, axisTags):
		...
	
	def fromXML(self, name, attrs, _content): # -> None:
		...
	
	def compile(self, axisTags, sharedCoordIndices=..., pointData=...): # -> tuple[Literal[b''], Literal[b'']] | tuple[bytes, bytes]:
		...
	
	def compileCoord(self, axisTags): # -> bytes:
		...
	
	def compileIntermediateCoord(self, axisTags): # -> bytearray | None:
		...
	
	@staticmethod
	def decompileCoord_(axisTags, data, offset): # -> tuple[dict[Unknown, Unknown], Unknown]:
		...
	
	@staticmethod
	def compilePoints(points): # -> bytearray | Literal[b'\u0000']:
		...
	
	@staticmethod
	def decompilePoints_(numPoints, data, offset, tableTag):
		"""(numPoints, data, offset, tableTag) --> ([point1, point2, ...], newOffset)"""
		...
	
	def compileDeltas(self): # -> bytearray:
		...
	
	@staticmethod
	def compileDeltaValues_(deltas, bytearr=...): # -> bytearray:
		"""[value1, value2, value3, ...] --> bytearray

		Emits a sequence of runs. Each run starts with a
		byte-sized header whose 6 least significant bits
		(header & 0x3F) indicate how many values are encoded
		in this run. The stored length is the actual length
		minus one; run lengths are thus in the range [1..64].
		If the header byte has its most significant bit (0x80)
		set, all values in this run are zero, and no data
		follows. Otherwise, the header byte is followed by
		((header & 0x3F) + 1) signed values.  If (header &
		0x40) is clear, the delta values are stored as signed
		bytes; if (header & 0x40) is set, the delta values are
		signed 16-bit integers.
		"""
		...
	
	@staticmethod
	def encodeDeltaRunAsZeroes_(deltas, offset, bytearr):
		...
	
	@staticmethod
	def encodeDeltaRunAsBytes_(deltas, offset, bytearr):
		...
	
	@staticmethod
	def encodeDeltaRunAsWords_(deltas, offset, bytearr):
		...
	
	@staticmethod
	def decompileDeltas_(numDeltas, data, offset): # -> tuple[list[Unknown], Unknown]:
		"""(numDeltas, data, offset) --> ([delta, delta, ...], newOffset)"""
		...
	
	@staticmethod
	def getTupleSize_(flags, axisCount): # -> Literal[4]:
		...
	
	def getCoordWidth(self): # -> Literal[0, 1, 2]:
		""" Return 2 if coordinates are (x, y) as in gvar, 1 if single values
		as in cvar, or 0 if empty.
		"""
		...
	
	def scaleDeltas(self, scalar): # -> None:
		...
	
	def roundDeltas(self): # -> None:
		...
	
	def calcInferredDeltas(self, origCoords, endPts): # -> None:
		...
	
	def optimize(self, origCoords, endPts, tolerance=..., isComposite=...): # -> None:
		...
	
	def __iadd__(self, other):
		...
	


def decompileSharedTuples(axisTags, sharedTupleCount, data, offset): # -> list[Unknown]:
	...

def compileSharedTuples(axisTags, variations, MAX_NUM_SHARED_COORDS=...): # -> list[Unknown]:
	...

def compileTupleVariationStore(variations, pointCount, axisTags, sharedTupleIndices, useSharedPoints=...): # -> tuple[Literal[0], Literal[b''], Literal[b'']] | tuple[int, bytes, bytes]:
	...

def decompileTupleVariationStore(tableTag, axisTags, tupleVariationCount, pointCount, sharedTuples, data, pos, dataPos): # -> list[Unknown]:
	...

def decompileTupleVariation_(pointCount, sharedTuples, sharedPoints, tableTag, axisTags, data, tupleData):
	...

def inferRegion_(peak): # -> tuple[dict[Unknown, Unknown], dict[Unknown, Unknown]]:
	"""Infer start and end for a (non-intermediate) region

	This helper function computes the applicability region for
	variation tuples whose INTERMEDIATE_REGION flag is not set in the
	TupleVariationHeader structure.  Variation tuples apply only to
	certain regions of the variation space; outside that region, the
	tuple has no effect.  To make the binary encoding more compact,
	TupleVariationHeaders can omit the intermediateStartTuple and
	intermediateEndTuple fields.
    """
	...

