"""
This type stub file was generated by pyright.
"""

from fontTools import version
from . import DefaultTable
from fontTools.misc.loggingTools import deprecateFunction

"""_g_l_y_f.py -- Converter classes for the 'glyf' table."""
log = ...
version = ...
SCALE_COMPONENT_OFFSET_DEFAULT = ...
class table__g_l_y_f(DefaultTable.DefaultTable):
	"""Glyph Data Table

	This class represents the `glyf <https://docs.microsoft.com/en-us/typography/opentype/spec/glyf>`_
 	table, which contains outlines for glyphs in TrueType format. In many cases,
 	it is easier to access and manipulate glyph outlines through the ``GlyphSet``
 	object returned from :py:meth:`fontTools.ttLib.ttFont.getGlyphSet`::

 			>> from fontTools.pens.boundsPen import BoundsPen
 			>> glyphset = font.getGlyphSet()
			>> bp = BoundsPen(glyphset)
			>> glyphset["A"].draw(bp)
			>> bp.bounds
			(19, 0, 633, 716)

	However, this class can be used for low-level access to the ``glyf`` table data.
	Objects of this class support dictionary-like access, mapping glyph names to
	:py:class:`Glyph` objects::

			>> glyf = font["glyf"]
			>> len(glyf["Aacute"].components)
			2

	Note that when adding glyphs to the font via low-level access to the ``glyf``
	table, the new glyphs must also be added to the ``hmtx``/``vmtx`` table::

			>> font["glyf"]["divisionslash"] = Glyph()
			>> font["hmtx"]["divisionslash"] = (640, 0)

	"""
	padding = ...
	def decompile(self, data, ttFont):
		...
	
	def compile(self, ttFont):
		...
	
	def toXML(self, writer, ttFont, splitGlyphs=...):
		...
	
	def fromXML(self, name, attrs, content, ttFont): # -> None:
		...
	
	def setGlyphOrder(self, glyphOrder): # -> None:
		"""Sets the glyph order

		Args:
			glyphOrder ([str]): List of glyph names in order.
		"""
		...
	
	def getGlyphName(self, glyphID):
		"""Returns the name for the glyph with the given ID.

		Raises a ``KeyError`` if the glyph name is not found in the font.
		"""
		...
	
	def getGlyphID(self, glyphName):
		"""Returns the ID of the glyph with the given name.

		Raises a ``ValueError`` if the glyph is not found in the font.
		"""
		...
	
	def removeHinting(self): # -> None:
		"""Removes TrueType hints from all glyphs in the glyphset.

		See :py:meth:`Glyph.removeHinting`.
		"""
		...
	
	def keys(self): # -> dict_keys[Unknown, Unknown]:
		...
	
	def has_key(self, glyphName): # -> bool:
		...
	
	__contains__ = ...
	def get(self, glyphName, default=...):
		...
	
	def __getitem__(self, glyphName):
		...
	
	def __setitem__(self, glyphName, glyph): # -> None:
		...
	
	def __delitem__(self, glyphName): # -> None:
		...
	
	def __len__(self): # -> int:
		...
	
	@deprecateFunction("use '_getPhantomPoints' instead", category=DeprecationWarning)
	def getPhantomPoints(self, glyphName, ttFont, defaultVerticalOrigin=...): # -> list[tuple[Unknown, Literal[0]] | tuple[Literal[0], Unknown | Literal[0]]]:
		"""Old public name for self._getPhantomPoints().
		See: https://github.com/fonttools/fonttools/pull/2266"""
		...
	
	@deprecateFunction("use '_getCoordinatesAndControls' instead", category=DeprecationWarning)
	def getCoordinatesAndControls(self, glyphName, ttFont, defaultVerticalOrigin=...): # -> tuple[GlyphCoordinates | Unknown, _GlyphControls] | None:
		"""Old public name for self._getCoordinatesAndControls().
		See: https://github.com/fonttools/fonttools/pull/2266"""
		...
	
	@deprecateFunction("use '_setCoordinates' instead", category=DeprecationWarning)
	def setCoordinates(self, glyphName, ttFont): # -> None:
		"""Old public name for self._setCoordinates().
		See: https://github.com/fonttools/fonttools/pull/2266"""
		...
	


_GlyphControls = ...
glyphHeaderFormat = ...
flagOnCurve = ...
flagXShort = ...
flagYShort = ...
flagRepeat = ...
flagXsame = ...
flagYsame = ...
flagOverlapSimple = ...
flagReserved = ...
keepFlags = ...
_flagSignBytes = ...
def flagBest(x, y, onCurve): # -> tuple[int, Literal[0, 1, 2, 3, 4]]:
	"""For a given x,y delta pair, returns the flag that packs this pair
	most efficiently, as well as the number of byte cost of such flag."""
	...

def flagFits(newFlag, oldFlag, mask): # -> bool:
	...

def flagSupports(newFlag, oldFlag): # -> bool:
	...

def flagEncodeCoord(flag, mask, coord, coordBytes): # -> None:
	...

def flagEncodeCoords(flag, x, y, xBytes, yBytes): # -> None:
	...

ARG_1_AND_2_ARE_WORDS = ...
ARGS_ARE_XY_VALUES = ...
ROUND_XY_TO_GRID = ...
WE_HAVE_A_SCALE = ...
NON_OVERLAPPING = ...
MORE_COMPONENTS = ...
WE_HAVE_AN_X_AND_Y_SCALE = ...
WE_HAVE_A_TWO_BY_TWO = ...
WE_HAVE_INSTRUCTIONS = ...
USE_MY_METRICS = ...
OVERLAP_COMPOUND = ...
SCALED_COMPONENT_OFFSET = ...
UNSCALED_COMPONENT_OFFSET = ...
CompositeMaxpValues = ...
class Glyph:
	"""This class represents an individual TrueType glyph.

	TrueType glyph objects come in two flavours: simple and composite. Simple
	glyph objects contain contours, represented via the ``.coordinates``,
	``.flags``, ``.numberOfContours``, and ``.endPtsOfContours`` attributes;
	composite glyphs contain components, available through the ``.components``
	attributes.

	Because the ``.coordinates`` attribute (and other simple glyph attributes mentioned
	above) is only set on simple glyphs and the ``.components`` attribute is only
	set on composite glyphs, it is necessary to use the :py:meth:`isComposite`
	method to test whether a glyph is simple or composite before attempting to
	access its data.

	For a composite glyph, the components can also be accessed via array-like access::

		>> assert(font["glyf"]["Aacute"].isComposite())
		>> font["glyf"]["Aacute"][0]
		<fontTools.ttLib.tables._g_l_y_f.GlyphComponent at 0x1027b2ee0>

	"""
	def __init__(self, data=...) -> None:
		...
	
	def compact(self, glyfTable, recalcBBoxes=...): # -> None:
		...
	
	def expand(self, glyfTable): # -> None:
		...
	
	def compile(self, glyfTable, recalcBBoxes=...): # -> Unknown | bytearray | bytes:
		...
	
	def toXML(self, writer, ttFont):
		...
	
	def fromXML(self, name, attrs, content, ttFont):
		...
	
	def getCompositeMaxpValues(self, glyfTable, maxComponentDepth=...): # -> CompositeMaxpValues:
		...
	
	def getMaxpValues(self): # -> tuple[int, int]:
		...
	
	def decompileComponents(self, data, glyfTable): # -> None:
		...
	
	def decompileCoordinates(self, data):
		...
	
	def decompileCoordinatesRaw(self, nCoordinates, data, pos=...):
		...
	
	def compileComponents(self, glyfTable): # -> bytes:
		...
	
	def compileCoordinates(self): # -> bytes:
		...
	
	def compileDeltasGreedy(self, flags, deltas):
		...
	
	def compileDeltasOptimal(self, flags, deltas):
		...
	
	def recalcBounds(self, glyfTable): # -> None:
		"""Recalculates the bounds of the glyph.

		Each glyph object stores its bounding box in the
		``xMin``/``yMin``/``xMax``/``yMax`` attributes. These bounds must be
		recomputed when the ``coordinates`` change. The ``table__g_l_y_f`` bounds
		must be provided to resolve component bounds.
		"""
		...
	
	def isComposite(self): # -> Any | bool:
		"""Test whether a glyph has components"""
		...
	
	def __getitem__(self, componentIndex):
		...
	
	def getCoordinates(self, glyfTable):
		"""Return the coordinates, end points and flags

		This method returns three values: A :py:class:`GlyphCoordinates` object,
		a list of the indexes of the final points of each contour (allowing you
		to split up the coordinates list into contours) and a list of flags.

		On simple glyphs, this method returns information from the glyph's own
		contours; on composite glyphs, it "flattens" all components recursively
		to return a list of coordinates representing all the components involved
		in the glyph.

		To interpret the flags for each point, see the "Simple Glyph Flags"
		section of the `glyf table specification <https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#simple-glyph-description>`.
		"""
		...
	
	def getComponentNames(self, glyfTable):
		"""Returns a list of names of component glyphs used in this glyph

		This method can be used on simple glyphs (in which case it returns an
		empty list) or composite glyphs.
		"""
		...
	
	def trim(self, remove_hinting=...):
		""" Remove padding and, if requested, hinting, from a glyph.
			This works on both expanded and compacted glyphs, without
			expanding it."""
		...
	
	def removeHinting(self): # -> None:
		"""Removes TrueType hinting instructions from the glyph."""
		...
	
	def draw(self, pen, glyfTable, offset=...):
		"""Draws the glyph using the supplied pen object.

		Arguments:
			pen: An object conforming to the pen protocol.
			glyfTable: A :py:class:`table__g_l_y_f` object, to resolve components.
			offset (int): A horizontal offset. If provided, all coordinates are
				translated by this offset.
		"""
		...
	
	def drawPoints(self, pen, glyfTable, offset=...):
		"""Draw the glyph using the supplied pointPen. As opposed to Glyph.draw(),
		this will not change the point indices.
		"""
		...
	
	def __eq__(self, other) -> bool:
		...
	
	def __ne__(self, other) -> bool:
		...
	


class GlyphComponent:
	"""Represents a component within a composite glyph.

	The component is represented internally with four attributes: ``glyphName``,
	``x``, ``y`` and ``transform``. If there is no "two-by-two" matrix (i.e
	no scaling, reflection, or rotation; only translation), the ``transform``
	attribute is not present.
	"""
	def __init__(self) -> None:
		...
	
	def getComponentInfo(self): # -> tuple[Unknown, tuple[Any | int | float, Any | int | float, Any | int | float, Any | int | float, Any, Any] | tuple[Literal[1], Literal[0], Literal[0], Literal[1], Any, Any]]:
		"""Return information about the component

		This method returns a tuple of two values: the glyph name of the component's
		base glyph, and a transformation matrix. As opposed to accessing the attributes
		directly, ``getComponentInfo`` always returns a six-element tuple of the
		component's transformation matrix, even when the two-by-two ``.transform``
		matrix is not present.
		"""
		...
	
	def decompile(self, data, glyfTable): # -> tuple[int, int, Unknown]:
		...
	
	def compile(self, more, haveInstructions, glyfTable):
		...
	
	def toXML(self, writer, ttFont): # -> None:
		...
	
	def fromXML(self, name, attrs, content, ttFont): # -> None:
		...
	
	def __eq__(self, other) -> bool:
		...
	
	def __ne__(self, other) -> bool:
		...
	


class GlyphCoordinates:
	"""A list of glyph coordinates.

	Unlike an ordinary list, this is a numpy-like matrix object which supports
	matrix addition, scalar multiplication and other operations described below.
	"""
	def __init__(self, iterable=...) -> None:
		...
	
	@property
	def array(self): # -> array[float]:
		"""Returns the underlying array of coordinates"""
		...
	
	@staticmethod
	def zeros(count): # -> GlyphCoordinates:
		"""Creates a new ``GlyphCoordinates`` object with all coordinates set to (0,0)"""
		...
	
	def copy(self): # -> GlyphCoordinates:
		"""Creates a new ``GlyphCoordinates`` object which is a copy of the current one."""
		...
	
	def __len__(self): # -> int:
		"""Returns the number of coordinates in the array."""
		...
	
	def __getitem__(self, k): # -> list[Unknown] | tuple[int | float, int | float]:
		"""Returns a two element tuple (x,y)"""
		...
	
	def __setitem__(self, k, v): # -> None:
		"""Sets a point's coordinates to a two element tuple (x,y)"""
		...
	
	def __delitem__(self, i): # -> None:
		"""Removes a point from the list"""
		...
	
	def __repr__(self): # -> str:
		...
	
	def append(self, p): # -> None:
		...
	
	def extend(self, iterable): # -> None:
		...
	
	def toInt(self, *, round=...): # -> None:
		...
	
	def relativeToAbsolute(self): # -> None:
		...
	
	def absoluteToRelative(self): # -> None:
		...
	
	def translate(self, p): # -> None:
		"""
		>>> GlyphCoordinates([(1,2)]).translate((.5,0))
		"""
		...
	
	def scale(self, p): # -> None:
		"""
		>>> GlyphCoordinates([(1,2)]).scale((.5,0))
		"""
		...
	
	def transform(self, t): # -> None:
		"""
		>>> GlyphCoordinates([(1,2)]).transform(((.5,0),(.2,.5)))
		"""
		...
	
	def __eq__(self, other) -> bool:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g2 = GlyphCoordinates([(1.0,2)])
		>>> g3 = GlyphCoordinates([(1.5,2)])
		>>> g == g2
		True
		>>> g == g3
		False
		>>> g2 == g3
		False
		"""
		...
	
	def __ne__(self, other) -> bool:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g2 = GlyphCoordinates([(1.0,2)])
		>>> g3 = GlyphCoordinates([(1.5,2)])
		>>> g != g2
		False
		>>> g != g3
		True
		>>> g2 != g3
		True
		"""
		...
	
	def __pos__(self): # -> GlyphCoordinates:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g
		GlyphCoordinates([(1, 2)])
		>>> g2 = +g
		>>> g2
		GlyphCoordinates([(1, 2)])
		>>> g2.translate((1,0))
		>>> g2
		GlyphCoordinates([(2, 2)])
		>>> g
		GlyphCoordinates([(1, 2)])
		"""
		...
	
	def __neg__(self): # -> GlyphCoordinates:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g
		GlyphCoordinates([(1, 2)])
		>>> g2 = -g
		>>> g2
		GlyphCoordinates([(-1, -2)])
		>>> g
		GlyphCoordinates([(1, 2)])
		"""
		...
	
	def __round__(self, *, round=...): # -> GlyphCoordinates:
		...
	
	def __add__(self, other): # -> GlyphCoordinates | _NotImplementedType:
		...
	
	def __sub__(self, other): # -> GlyphCoordinates | _NotImplementedType:
		...
	
	def __mul__(self, other): # -> GlyphCoordinates | _NotImplementedType:
		...
	
	def __truediv__(self, other): # -> GlyphCoordinates | _NotImplementedType:
		...
	
	__radd__ = ...
	__rmul__ = ...
	def __rsub__(self, other):
		...
	
	def __iadd__(self, other): # -> Self@GlyphCoordinates | _NotImplementedType:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g += (.5,0)
		>>> g
		GlyphCoordinates([(1.5, 2)])
		>>> g2 = GlyphCoordinates([(3,4)])
		>>> g += g2
		>>> g
		GlyphCoordinates([(4.5, 6)])
		"""
		...
	
	def __isub__(self, other): # -> Self@GlyphCoordinates | _NotImplementedType:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g -= (.5,0)
		>>> g
		GlyphCoordinates([(0.5, 2)])
		>>> g2 = GlyphCoordinates([(3,4)])
		>>> g -= g2
		>>> g
		GlyphCoordinates([(-2.5, -2)])
		"""
		...
	
	def __imul__(self, other): # -> Self@GlyphCoordinates | _NotImplementedType:
		"""
		>>> g = GlyphCoordinates([(1,2)])
		>>> g *= (2,.5)
		>>> g *= 2
		>>> g
		GlyphCoordinates([(4, 2)])
		>>> g = GlyphCoordinates([(1,2)])
		>>> g *= 2
		>>> g
		GlyphCoordinates([(2, 4)])
		"""
		...
	
	def __itruediv__(self, other): # -> Self@GlyphCoordinates | _NotImplementedType:
		"""
		>>> g = GlyphCoordinates([(1,3)])
		>>> g /= (.5,1.5)
		>>> g /= 2
		>>> g
		GlyphCoordinates([(1, 1)])
		"""
		...
	
	def __bool__(self): # -> bool:
		"""
		>>> g = GlyphCoordinates([])
		>>> bool(g)
		False
		>>> g = GlyphCoordinates([(0,0), (0.,0)])
		>>> bool(g)
		True
		>>> g = GlyphCoordinates([(0,0), (1,0)])
		>>> bool(g)
		True
		>>> g = GlyphCoordinates([(0,.5), (0,0)])
		>>> bool(g)
		True
		"""
		...
	
	__nonzero__ = ...


if __name__ == "__main__":
	...
