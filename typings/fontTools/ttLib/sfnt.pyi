"""
This type stub file was generated by pyright.
"""

"""ttLib/sfnt.py -- low-level module to deal with the sfnt file format.

Defines two public classes:
	SFNTReader
	SFNTWriter

(Normally you don't have to use these classes explicitly; they are
used automatically by ttLib.TTFont.)

The reading and writing of sfnt files is separated in two distinct
classes, since whenever the number of tables changes or whenever
a table's length changes you need to rewrite the whole file anyway.
"""
log = ...
class SFNTReader:
	def __new__(cls, *args, **kwargs): # -> WOFF2Reader | Self@SFNTReader:
		""" Return an instance of the SFNTReader sub-class which is compatible
		with the input file type.
		"""
		...
	
	def __init__(self, file, checkChecksums=..., fontNumber=...) -> None:
		...
	
	def has_key(self, tag): # -> bool:
		...
	
	__contains__ = ...
	def keys(self): # -> _OrderedDictKeysView[Unknown, Unknown]:
		...
	
	def __getitem__(self, tag):
		"""Fetch the raw table data."""
		...
	
	def __delitem__(self, tag): # -> None:
		...
	
	def close(self): # -> None:
		...
	
	def __getstate__(self): # -> dict[str, Any]:
		...
	
	def __setstate__(self, state): # -> None:
		...
	


ZLIB_COMPRESSION_LEVEL = ...
USE_ZOPFLI = ...
ZOPFLI_LEVELS = ...
def compress(data, level=...): # -> bytes:
	""" Compress 'data' to Zlib format. If 'USE_ZOPFLI' variable is True,
	zopfli is used instead of the zlib module.
	The compression 'level' must be between 0 and 9. 1 gives best speed,
	9 gives best compression (0 gives no compression at all).
	The default value is a compromise between speed and compression (6).
	"""
	...

class SFNTWriter:
	def __new__(cls, *args, **kwargs): # -> WOFF2Writer | Self@SFNTWriter:
		""" Return an instance of the SFNTWriter sub-class which is compatible
		with the specified 'flavor'.
		"""
		...
	
	def __init__(self, file, numTables, sfntVersion=..., flavor=..., flavorData=...) -> None:
		...
	
	def setEntry(self, tag, entry): # -> None:
		...
	
	def __setitem__(self, tag, data): # -> None:
		"""Write raw table data to disk."""
		...
	
	def __getitem__(self, tag):
		...
	
	def close(self): # -> None:
		"""All tables must have been written to disk. Now write the
		directory.
		"""
		...
	
	def writeMasterChecksum(self, directory): # -> None:
		...
	
	def reordersTables(self): # -> Literal[False]:
		...
	


ttcHeaderFormat = ...
ttcHeaderSize = ...
sfntDirectoryFormat = ...
sfntDirectorySize = ...
sfntDirectoryEntryFormat = ...
sfntDirectoryEntrySize = ...
woffDirectoryFormat = ...
woffDirectorySize = ...
woffDirectoryEntryFormat = ...
woffDirectoryEntrySize = ...
class DirectoryEntry:
	def __init__(self) -> None:
		...
	
	def fromFile(self, file): # -> None:
		...
	
	def fromString(self, str): # -> None:
		...
	
	def toString(self): # -> bytes:
		...
	
	def __repr__(self): # -> str:
		...
	
	def loadData(self, file):
		...
	
	def saveData(self, file, data): # -> None:
		...
	
	def decodeData(self, rawData):
		...
	
	def encodeData(self, data):
		...
	


class SFNTDirectoryEntry(DirectoryEntry):
	format = ...
	formatSize = ...


class WOFFDirectoryEntry(DirectoryEntry):
	format = ...
	formatSize = ...
	def __init__(self) -> None:
		...
	
	def decodeData(self, rawData): # -> bytes:
		...
	
	def encodeData(self, data): # -> bytes:
		...
	


class WOFFFlavorData:
	Flavor = ...
	def __init__(self, reader=...) -> None:
		...
	


def calcChecksum(data): # -> Any | int:
	"""Calculate the checksum for an arbitrary block of data.

	If the data length is not a multiple of four, it assumes
	it is to be padded with null byte.

		>>> print(calcChecksum(b"abcd"))
		1633837924
		>>> print(calcChecksum(b"abcdxyz"))
		3655064932
	"""
	...

def readTTCHeader(file): # -> SimpleNamespace:
	...

def writeTTCHeader(file, numFonts):
	...

if __name__ == "__main__":
	...
